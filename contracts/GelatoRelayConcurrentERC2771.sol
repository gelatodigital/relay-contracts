// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

import {
    IGelatoRelayConcurrentERC2771
} from "./interfaces/IGelatoRelayConcurrentERC2771.sol";
import {
    GelatoRelayConcurrentERC2771Base
} from "./abstract/GelatoRelayConcurrentERC2771Base.sol";
import {GelatoCallUtils} from "./lib/GelatoCallUtils.sol";
import {GelatoTokenUtils} from "./lib/GelatoTokenUtils.sol";
import {CallWithConcurrentERC2771} from "./types/CallTypes.sol";
import {
    _encodeFeeCollectorERC2771,
    _encodeRelayContextERC2771
} from "@gelatonetwork/relay-context/contracts/functions/GelatoRelayUtils.sol";
import {
    _getFeeCollectorRelayContext,
    _getFeeRelayContext
} from "@gelatonetwork/relay-context/contracts/GelatoRelayContext.sol";
import {
    __getFeeCollector
} from "@gelatonetwork/relay-context/contracts/GelatoRelayFeeCollector.sol";

/// @title  Gelato Relay contract
/// @notice This contract deals with synchronous payments and Gelato 1Balance payments
/// @dev    This contract must NEVER hold funds!
/// @dev    Maliciously crafted transaction payloads could wipe out any funds left here
// solhint-disable-next-line max-line-length
contract GelatoRelayConcurrentERC2771 is
    IGelatoRelayConcurrentERC2771,
    GelatoRelayConcurrentERC2771Base
{
    using GelatoCallUtils for address;
    using GelatoTokenUtils for address;

    //solhint-disable-next-line const-name-snakecase
    string public constant name = "GelatoRelayConcurrentERC2771";
    //solhint-disable-next-line const-name-snakecase
    string public constant version = "1";

    // solhint-disable-next-line no-empty-blocks
    constructor(address _gelato) GelatoRelayConcurrentERC2771Base(_gelato) {}

    /// @notice Relay call with Synchronous Payment
    /// @notice The target contract pays Gelato during the call forward
    /// @dev    This is the most straightforward use case, and `transfer` handles token payments.
    /// @param _call Relay call data packed into CallWithConcurrentERC2771 struct
    /// @param _isRelayContext true: all relay context encoding, false: only feeCollector encoding
    /// @param _correlationId Unique task identifier generated by gelato
    // solhint-disable-next-line function-max-lines
    function callWithSyncFeeConcurrentERC2771(
        CallWithConcurrentERC2771 calldata _call,
        address _feeToken,
        bytes calldata _userSignature,
        bool _isRelayContext,
        bytes32 _correlationId
    ) external onlyGelato {
        // CHECKS
        _requireChainId(
            _call.chainId,
            "GelatoRelayConcurrentERC2771.callWithSyncFeeConcurrentERC2771:"
        );

        _requireUserDeadline(
            _call.userDeadline,
            "GelatoRelayConcurrentERC2771.callWithSyncFeeConcurrentERC2771:"
        );

        bytes32 callHash = _hashCallWithSyncFeeConcurrentERC2771(_call);

        // For the user, we enforce hash-based replay protection
        _requireUnusedHash(
            callHash,
            "GelatoRelayConcurrentERC2771.callWithSyncFeeConcurrentERC2771:"
        );

        bytes32 domainSeparator = _getDomainSeparator();

        // Verify user's signature
        _requireCallWithSyncFeeConcurrentERC2771Signature(
            domainSeparator,
            callHash,
            _userSignature,
            _call.user
        );

        // EFFECTS
        hashUsed[callHash] = true;

        // INTERACTIONS
        _isRelayContext
            ? _call.target.revertingContractCall(
                _encodeRelayContextERC2771(
                    _call.data,
                    _getFeeCollectorRelayContext(),
                    _feeToken,
                    _getFeeRelayContext(),
                    _call.user
                ),
                "GelatoRelayConcurrentERC2771.callWithSyncFeeConcurrentERC2771:"
            )
            : _call.target.revertingContractCall(
                _encodeFeeCollectorERC2771(
                    _call.data,
                    __getFeeCollector(),
                    _call.user
                ),
                "GelatoRelayConcurrentERC2771.callWithSyncFeeConcurrentERC2771:"
            );

        emit LogCallWithSyncFeeConcurrentERC2771(_call.target, _correlationId);
    }

    //solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _getDomainSeparator();
    }

    function _getDomainSeparator() internal view returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    keccak256(
                        bytes(
                            //solhint-disable-next-line max-line-length
                            "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
                        )
                    ),
                    keccak256(bytes(name)),
                    keccak256(bytes(version)),
                    block.chainid,
                    address(this)
                )
            );
    }
}
