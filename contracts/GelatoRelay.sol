// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import {IGelatoRelay} from "./interfaces/IGelatoRelay.sol";
import {GelatoCallUtils} from "./lib/GelatoCallUtils.sol";
import {GelatoTokenUtils} from "./lib/GelatoTokenUtils.sol";
import {
    _encodeFeeCollector,
    _encodeRelayContext
} from "@gelatonetwork/relay-context/contracts/functions/GelatoRelayUtils.sol";
import {
    __getFeeCollector
} from "@gelatonetwork/relay-context/contracts/GelatoRelayFeeCollector.sol";
import {
    _getFeeCollectorRelayContext,
    _getFeeTokenRelayContext,
    _getFeeRelayContext
} from "@gelatonetwork/relay-context/contracts/GelatoRelayContext.sol";

/// @title  Gelato Relay contract
/// @notice This contract deals with synchronous payments and Gelato 1Balance payments
/// @dev    This contract must NEVER hold funds!
/// @dev    Maliciously crafted transaction payloads could wipe out any funds left here
// solhint-disable-next-line max-states-count
contract GelatoRelay is IGelatoRelay {
    using GelatoCallUtils for address;
    using GelatoTokenUtils for address;

    address public immutable gelato;

    modifier onlyGelato() {
        require(msg.sender == gelato, "Only callable by gelato");
        _;
    }

    constructor(address _gelato) {
        gelato = _gelato;
    }

    /// @notice Relay call with Synchronous Payment
    /// @notice The target contract pays Gelato during the call forward
    /// @dev    This is the most straightforward use case, and `transfer` handles token payments.
    /// @param _target Target smart contract
    /// @param _data Payload for call on _target
    /// @param _isRelayContext true: all relay context encoding, false: only feeCollector encoding
    /// @param _correlationId Unique task identifier generated by gelato
    function callWithSyncFeeV2(
        address _target,
        bytes calldata _data,
        bool _isRelayContext,
        bytes32 _correlationId
    ) external onlyGelato {
        address feeToken;
        address feeCollector;
        uint256 preBalance;

        if (_isRelayContext) {
            feeCollector = _getFeeCollectorRelayContext();
            feeToken = _getFeeTokenRelayContext();
            preBalance = feeToken.getBalance(address(this));
        }

        _isRelayContext
            ? _target.revertingContractCall(
                _encodeRelayContext(
                    _data,
                    feeCollector,
                    feeToken,
                    _getFeeRelayContext()
                ),
                "GelatoRelay.callWithSyncFeeV2:"
            )
            : _target.revertingContractCall(
                _encodeFeeCollector(_data, __getFeeCollector()),
                "GelatoRelay.callWithSyncFeeV2:"
            );

        if (_isRelayContext) {
            uint256 fee = feeToken.getBalance(address(this)) - preBalance;
            if (fee != 0) feeToken.transfer(feeCollector, fee);
        }

        emit LogCallWithSyncFeeV2(_target, _correlationId);
    }
}
