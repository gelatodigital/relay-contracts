// SPDX-License-Identifier: MIT
pragma solidity 0.8.15;

import {IGelatoRelay} from "./interfaces/IGelatoRelay.sol";
import {IGelato1Balance} from "./interfaces/IGelato1Balance.sol";
import {GelatoRelayBase} from "./GelatoRelayBase.sol";
import {GelatoCallUtils} from "./lib/GelatoCallUtils.sol";
import {GelatoTokenUtils} from "./lib/GelatoTokenUtils.sol";
import {
    SponsorAuthCall,
    UserAuthCall,
    UserSponsorAuthCall
} from "./types/CallTypes.sol";
import {IGelato} from "./interfaces/IGelato.sol";
import {PaymentType} from "./types/PaymentTypes.sol";

/// @title  Gelato Relay contract
/// @notice This contract deals with synchronous payments and Gelato 1Balance payments
/// @dev    This contract must NEVER hold funds!
/// @dev    Maliciously crafted transaction payloads could wipe out any funds left here
// solhint-disable-next-line max-states-count
contract GelatoRelay is IGelatoRelay, IGelato1Balance, GelatoRelayBase {
    using GelatoCallUtils for address;
    using GelatoTokenUtils for address;

    // solhint-disable-next-line no-empty-blocks
    constructor(address _gelato) GelatoRelayBase(_gelato) {}

    /// @notice Relay call with Synchronous Payment
    /// @notice The target contract pays Gelato during the call forward
    /// @dev    This is the most straightforward use case, and `transfer` handles token payments.
    /// @param _target Target smart contract
    /// @param _data Payload for call on _target
    /// @param _feeToken Payment can be done in native and ERC-20 tokens
    /// @param _gelatoFee Fee to be charged, denominated in feeToken
    /// @param _taskId Unique task indentifier generated by gelato
    function callWithSyncFee(
        address _target,
        bytes calldata _data,
        address _feeToken,
        uint256 _gelatoFee,
        bytes32 _taskId
    ) external onlyGelato {
        uint256 preBalance = _feeToken.getBalance(address(this));

        _target.revertingContractCall(_data, "GelatoRelay.callWithSyncFee:");

        uint256 postBalance = _feeToken.getBalance(address(this));

        uint256 amount = postBalance - preBalance;
        require(amount >= _gelatoFee, "Insufficient fee");

        _feeToken.transfer(IGelato(gelato).getFeeCollector(), amount);

        emit LogCallWithSyncFee(_target, _feeToken, amount, _taskId);
    }

    /// @notice Relay call + One Balance payment - with sponsor authentication
    /// @notice Sponsor signature allows for payment via sponsor's 1Balance balance
    /// @dev    Payment is handled with off-chain accounting using Gelato's 1Balance system
    /// @param _call Relay call data packed into SponsorAuthCall struct
    /// @param _sponsorSignature EIP-712 compliant signature from _call.sponsor
    /// @param _gelatoFee Fee to be charged by Gelato relayer, denominated in _call.feeToken
    /// @notice Oracle value for exchange rate between native tokens and fee token
    /// @param  _nativeToFeeTokenXRateNumerator Exchange rate numerator
    /// @param  _nativeToFeeTokenXRateDenominator Exchange rate denominator
    /// @param _taskId Unique task indentifier generated by gelato
    // solhint-disable-next-line function-max-lines
    function sponsorAuthCallWith1Balance(
        SponsorAuthCall calldata _call,
        bytes calldata _sponsorSignature,
        uint256 _gelatoFee,
        uint256 _nativeToFeeTokenXRateNumerator,
        uint256 _nativeToFeeTokenXRateDenominator,
        bytes32 _taskId
    ) external onlyGelato {
        // CHECKS
        _requireBasics(
            _call.chainId,
            _call.paymentType,
            _gelatoFee,
            _call.maxFee,
            "GelatoRelay.userSponsorAuthCallWith1Balance:"
        );

        // Do not enforce ordering on nonces,
        // but still enforce replay protection
        // via uniqueness of message
        bytes32 digest = _verifySponsorAuthCallSignature(
            _call,
            _sponsorSignature,
            _call.sponsor
        );
        require(
            !wasCallSponsoredAlready[digest],
            "GelatoRelay.sponsorAuthCallWith1Balance: replay"
        );

        // EFFECTS
        wasCallSponsoredAlready[digest] = true;

        // INTERACTIONS
        _call.target.revertingContractCall(
            _call.data,
            "GelatoRelay.sponsorAuthCallWith1Balance:"
        );

        emit LogUseGelato1Balance(
            _call.sponsor,
            _call.target,
            _call.feeToken,
            _call.oneBalanceChainId,
            _nativeToFeeTokenXRateNumerator,
            _nativeToFeeTokenXRateDenominator,
            _taskId
        );
        emit LogSponsorNonce(_call.sponsor, _call.sponsorNonce);
    }

    /// @notice Relay call + One Balance payment - with ONLY user authentication.
    /// @notice The user here is paying for themselves, no external sponsor
    /// @notice User signature allows for payment via user's 1Balance balance
    /// @dev    Payment is handled with off-chain accounting using Gelato's 1Balance system
    /// @dev    The userNonce abstraction does not support multiple calls (call concurrency)
    /// @dev    Apps that need concurrent user calls will need to implement multi-calling
    /// @dev    on their end via encoding into _call.data.
    /// @param _call Relay call data packed into UserAuthCall struct
    /// @param _userSignature EIP-712 compliant signature from _call.user
    /// @param _gelatoFee Fee to be charged by Gelato relayer, denominated in _call.feeToken
    /// @notice Oracle value for exchange rate between native tokens and fee token
    /// @param  _nativeToFeeTokenXRateNumerator Exchange rate numerator
    /// @param  _nativeToFeeTokenXRateDenominator Exchange rate denominator
    /// @param _taskId Unique task indentifier generated by gelato
    // solhint-disable-next-line function-max-lines
    function userAuthCallWith1Balance(
        UserAuthCall calldata _call,
        bytes calldata _userSignature,
        uint256 _gelatoFee,
        uint256 _nativeToFeeTokenXRateNumerator,
        uint256 _nativeToFeeTokenXRateDenominator,
        bytes32 _taskId
    ) external onlyGelato {
        // CHECKS
        _requireBasics(
            _call.chainId,
            _call.paymentType,
            _gelatoFee,
            _call.maxFee,
            "GelatoRelay.userAuthCallWith1Balance:"
        );

        // For the user, we enforce nonce ordering
        _requireUserBasics(
            _call.userNonce,
            userNonce[_call.user],
            _call.userDeadline,
            "GelatoRelay.userSponsorAuthCallWith1Balance"
        );

        _verifyUserAuthCallSignature(_call, _userSignature, _call.user);

        // EFFECTS
        userNonce[_call.user]++;

        // INTERACTIONS
        _call.target.revertingContractCall(
            _call.data,
            "GelatoRelay.sponsorAuthCallWith1Balance:"
        );

        emit LogUseGelato1Balance(
            _call.user,
            _call.target,
            _call.feeToken,
            _call.oneBalanceChainId,
            _nativeToFeeTokenXRateNumerator,
            _nativeToFeeTokenXRateDenominator,
            _taskId
        );
    }

    /// @notice Relay call + One Balance payment - with BOTH sponsor and user authentication
    /// @notice Both sponsor and user signature allows for payment via sponsor's 1Balance balance
    /// @dev    Payment is handled with off-chain accounting using Gelato's 1Balance system
    /// @dev    The userNonce abstraction does not support multiple calls (call concurrency)
    /// @dev    Apps that need concurrent user calls will need to implement multi-calling
    /// @dev    on their end via encoding into _call.data.
    /// @param _call Relay call data packed into UserSponsorAuthCall struct
    /// @param _userSignature EIP-712 compliant signature from _call.user
    /// @param _sponsorSignature EIP-712 compliant signature from _call.sponsor
    /// @param _gelatoFee Fee to be charged by Gelato relayer, denominated in _call.feeToken
    /// @param  _nativeToFeeTokenXRateNumerator Exchange rate numerator
    /// @param  _nativeToFeeTokenXRateDenominator Exchange rate denominator
    /// @param _taskId Unique task indentifier generated by gelato
    // solhint-disable-next-line function-max-lines
    function userSponsorAuthCallWith1Balance(
        UserSponsorAuthCall calldata _call,
        bytes calldata _userSignature,
        bytes calldata _sponsorSignature,
        uint256 _gelatoFee,
        uint256 _nativeToFeeTokenXRateNumerator,
        uint256 _nativeToFeeTokenXRateDenominator,
        bytes32 _taskId
    ) external onlyGelato {
        // CHECKS
        _requireBasics(
            _call.chainId,
            _call.paymentType,
            _gelatoFee,
            _call.maxFee,
            "GelatoRelay.userSponsorAuthCallWith1Balance:"
        );

        // For the user, we enforce nonce ordering
        _requireUserBasics(
            _call.userNonce,
            userNonce[_call.user],
            _call.userDeadline,
            "GelatoRelay.userSponsorAuthCallWith1Balance"
        );

        // Verify user's signature
        _verifyUserSponsorAuthCallSignature(_call, _userSignature, _call.user);

        // Verify sponsor's signature
        // Do not enforce ordering on nonces but still enforce replay protection
        // via uniqueness of call with nonce
        bytes32 digest = _verifyUserSponsorAuthCallSignature(
            _call,
            _sponsorSignature,
            _call.sponsor
        );

        // Sponsor replay protection
        require(
            !wasCallSponsoredAlready[digest],
            "GelatoRelay.sponsorAuthCallWith1Balance: replay"
        );

        // EFFECTS
        userNonce[_call.user]++;
        wasCallSponsoredAlready[digest] = true;

        // INTERACTIONS
        _call.target.revertingContractCall(
            _call.data,
            "GelatoRelay.userSponsorAuthCall1Balance:"
        );

        emit LogUseGelato1Balance(
            _call.sponsor,
            _call.target,
            _call.feeToken,
            _call.oneBalanceChainId,
            _nativeToFeeTokenXRateNumerator,
            _nativeToFeeTokenXRateDenominator,
            _taskId
        );
        emit LogSponsorNonce(_call.sponsor, _call.sponsorNonce);
    }
}
