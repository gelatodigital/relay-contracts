{
  "language": "Solidity",
  "sources": {
    "contracts/__mocks__/MockGelato.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {\n    ExecWithSigsFeeCollector,\n    ExecWithSigsRelayContext\n} from \"../types/DiamondCallTypes.sol\";\nimport {GelatoBytes} from \"../lib/GelatoBytes.sol\";\nimport {GelatoCallUtils} from \"../lib/GelatoCallUtils.sol\";\nimport {\n    _encodeFeeCollector,\n    _encodeGelatoRelayContext\n} from \"../functions/ContextUtils.sol\";\n\ncontract MockGelato {\n    using GelatoCallUtils for address;\n\n    address public immutable feeCollector;\n\n    constructor(address _feeCollector) {\n        feeCollector = _feeCollector;\n    }\n\n    function execWithSigsFeeCollector(ExecWithSigsFeeCollector calldata _call)\n        external\n    {\n        // call forward + append fee collector\n        (bool success, bytes memory returndata) = _call.msg.service.call(\n            _encodeFeeCollector(_call.msg.data, feeCollector)\n        );\n\n        if (!success)\n            GelatoBytes.revertWithError(\n                returndata,\n                \"ExecWithSigsFacet.ExecWithSigsFeeCollector:\"\n            );\n    }\n\n    function execWithSigsRelayContext(ExecWithSigsRelayContext calldata _call)\n        external\n    {\n        // call forward + append fee collector, feeToken, fee\n        _call.msg.service.revertingContractCall(\n            _encodeGelatoRelayContext(\n                _call.msg.data,\n                feeCollector,\n                _call.msg.feeToken,\n                _call.msg.fee\n            ),\n            \"ExecWithSigsFacet.execWithSigsRelayContext:\"\n        );\n    }\n}\n"
    },
    "contracts/types/DiamondCallTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nstruct Message {\n    address service;\n    bytes data;\n    uint256 salt;\n    uint256 deadline;\n}\n\nstruct MessageFeeCollector {\n    address service;\n    bytes data;\n    uint256 salt;\n    uint256 deadline;\n    address feeToken;\n}\n\nstruct MessageRelayContext {\n    address service;\n    bytes data;\n    uint256 salt;\n    uint256 deadline;\n    address feeToken;\n    uint256 fee;\n}\n\nstruct ExecWithSigs {\n    bytes32 correlationId;\n    Message msg;\n    bytes executorSignerSig;\n    bytes checkerSignerSig;\n}\n\nstruct ExecWithSigsFeeCollector {\n    bytes32 correlationId;\n    MessageFeeCollector msg;\n    bytes executorSignerSig;\n    bytes checkerSignerSig;\n}\n\nstruct ExecWithSigsRelayContext {\n    bytes32 correlationId;\n    MessageRelayContext msg;\n    bytes executorSignerSig;\n    bytes checkerSignerSig;\n}"
    },
    "contracts/lib/GelatoBytes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nlibrary GelatoBytes {\n    function calldataSliceSelector(bytes calldata _bytes)\n        internal\n        pure\n        returns (bytes4 selector)\n    {\n        selector =\n            _bytes[0] |\n            (bytes4(_bytes[1]) >> 8) |\n            (bytes4(_bytes[2]) >> 16) |\n            (bytes4(_bytes[3]) >> 24);\n    }\n\n    function memorySliceSelector(bytes memory _bytes)\n        internal\n        pure\n        returns (bytes4 selector)\n    {\n        selector =\n            _bytes[0] |\n            (bytes4(_bytes[1]) >> 8) |\n            (bytes4(_bytes[2]) >> 16) |\n            (bytes4(_bytes[3]) >> 24);\n    }\n\n    function revertWithError(bytes memory _bytes, string memory _tracingInfo)\n        internal\n        pure\n    {\n        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err\n        if (_bytes.length % 32 == 4) {\n            bytes4 selector;\n            assembly {\n                selector := mload(add(0x20, _bytes))\n            }\n            if (selector == 0x08c379a0) {\n                // Function selector for Error(string)\n                assembly {\n                    _bytes := add(_bytes, 68)\n                }\n                revert(string(abi.encodePacked(_tracingInfo, string(_bytes))));\n            } else {\n                revert(\n                    string(abi.encodePacked(_tracingInfo, \"NoErrorSelector\"))\n                );\n            }\n        } else {\n            revert(\n                string(abi.encodePacked(_tracingInfo, \"UnexpectedReturndata\"))\n            );\n        }\n    }\n\n    function returnError(bytes memory _bytes, string memory _tracingInfo)\n        internal\n        pure\n        returns (string memory)\n    {\n        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err\n        if (_bytes.length % 32 == 4) {\n            bytes4 selector;\n            assembly {\n                selector := mload(add(0x20, _bytes))\n            }\n            if (selector == 0x08c379a0) {\n                // Function selector for Error(string)\n                assembly {\n                    _bytes := add(_bytes, 68)\n                }\n                return string(abi.encodePacked(_tracingInfo, string(_bytes)));\n            } else {\n                return\n                    string(abi.encodePacked(_tracingInfo, \"NoErrorSelector\"));\n            }\n        } else {\n            return\n                string(abi.encodePacked(_tracingInfo, \"UnexpectedReturndata\"));\n        }\n    }\n}\n"
    },
    "contracts/lib/GelatoCallUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {GelatoBytes} from \"./GelatoBytes.sol\";\n\nlibrary GelatoCallUtils {\n    using GelatoBytes for bytes;\n\n    function revertingContractCall(\n        address _contract,\n        bytes memory _data,\n        string memory _errorMsg\n    ) internal returns (bytes memory returndata) {\n        bool success;\n        (success, returndata) = _contract.call(_data);\n\n        // solhint-disable-next-line max-line-length\n        // https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/f9b6fc3fdab7aca33a9cfa8837c5cd7f67e176be/contracts/utils/AddressUpgradeable.sol#L177\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(\n                    isContract(_contract),\n                    string(abi.encodePacked(_errorMsg, \"Call to non contract\"))\n                );\n            }\n        } else {\n            returndata.revertWithError(_errorMsg);\n        }\n    }\n\n    // solhint-disable-next-line max-line-length\n    // https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/f9b6fc3fdab7aca33a9cfa8837c5cd7f67e176be/contracts/utils/AddressUpgradeable.sol#L36\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n}\n"
    },
    "contracts/functions/ContextUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// solhint-disable-next-line private-vars-leading-underscore, func-visibility\nfunction _eip2771Context(bytes calldata _data, address _msgSender)\n    pure\n    returns (bytes memory)\n{\n    return abi.encodePacked(_data, _msgSender);\n}\n\nfunction _encodeGelatoRelayContext(\n    bytes calldata _data,\n    address _feeCollector,\n    address _feeToken,\n    uint256 _fee\n) pure returns (bytes memory) {\n    return abi.encodePacked(_data, abi.encode(_feeCollector, _feeToken, _fee));\n}\n\nfunction _encodeFeeCollector(bytes calldata _data, address _feeCollector)\n    pure\n    returns (bytes memory)\n{\n    return abi.encodePacked(_data, abi.encode(_feeCollector));\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}